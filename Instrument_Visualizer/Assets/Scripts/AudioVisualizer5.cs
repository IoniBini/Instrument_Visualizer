using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class AudioVisualizer5 : MonoBehaviour
{
    //Just like in my previous assignment, this visualizer is NOT the first I have made, and the previous failed versions are all stored in the legacy folder
    //here is a legend of nomenclature I use for ease of use for you:

    //Instrument = Obj which contains the AudioVisualizer5
    //Band = each individual child of the instrument
    //Microphone = an audio input device the computer is using

    //BEFORE YOU BEGIN READING THIS CODE
    //there is a known "glitch" in this system. If you change the order of bands within "band parameters",
    //it will completely mess up the range capture system, making it so that the high and low frequencies BOTH get caught by the same band. This can be fixed
    //by either returning the bands to their original order, or simply deleting all the bands from the list, and adding new ones in their place.
    //I have NO idea why this happens but I guess it could be some "hangover information" 
    //that for some reason permiates between swapping from play time to edit time. 

    //properties used in changing the colour of the property block
    [HideInInspector] public List<Color> currentColor;
    [HideInInspector] public Color colorAverage;

    [Tooltip("In case you want to see the numbers that are being collected from the audio spectrum generated by the audio source")]
    [SerializeField] private float[] spectrum;

    [Space]

    #region Skybox Shader Properties
    [Header("Skybox Shader Properties")]
    [Space]

    [Tooltip("The maximum value an instrument is capable of producing overall in relation to the skybox shader. A higher value makes the instrument output smaller for the shader")]
    public float maxShaderPositionLerp = 10;
    [Tooltip("The number of frequencies of sin waves used in the shader")]
    public AnimationCurve shaderFrequencyMultiplier;
    [Tooltip("The speed at which the sin waves used in the shader move")]
    public float shaderSpeedMultiplier = 2;

    //properties used in changing the properties in the skybox shader
    [HideInInspector] public float shaderFrequencyLerp;
    [HideInInspector] public float shaderSpeedLerp;
    #endregion

    #region Audio Source
    [Space]
    [Header("This Instrument's Audio Source")]
    [Space]

    [Tooltip("In a situation where you want more than one visualizer to pick up the same microphone, you CANNOT simply have the voice detection script choose two of the same input, it breaks, " +
        "hence, I made the audio source public just in case you want to assign multiple instruments to the same input. Leave empty in case you want to use this instrument's own audio source.")]
    public AudioSource overrideAudioSource;
    private AudioSource actualAudioSource;
    #endregion

    #region Event System
    [Space]

    [Tooltip("When this instrument reaches a certain threshold of output intensity, it will trigger events present in this list")]
    public List<UnityEvent> InstrumentEvents;
    [Tooltip("The threshold that needs to be reached in order for an event to be triggered")]
    [Min(1.1f)] public float eventFreqTrigger = 1.1f;
    private bool canTriggerEvents = true;
    [Tooltip("When false, all the events in the list will play when the threshold is reached, but if false, it will only play one, picked at random")]
    public bool randomlyPickOneEvent = false;

    [Space]
    #endregion

    #region Instrument Band Obj Properties
    [Header("Instrument Band Obj Properties")]
    [Space]

    [Tooltip("If true, it will respawn all the objs the instrument uses, if false, it won't. This is so that if you want to move the position of each individual child band and not have" +
        " them be destroyed on spawn, you can use this bool")]
    public bool generateObjsOnSpawn = true;
    [Tooltip("The amount of space that the child bands will occupy")]
    public float visualizerSpan = 10;
    [Tooltip("The prefab that is used as the bands")]
    public GameObject visualizerObj;

    [Space]
    #endregion

    #region Band Parameters
    [Space]

    [Tooltip("The parameters used in each individual band (child) of the instrument(audio visualizer)")]
    public BandParameters[] bandParameters;

    [System.Serializable]
    public struct BandParameters
    {
        [Tooltip("Captures a range of frequencies present between the values in each vector2, then averages them all into one band")]
        public List<Vector2> bandRange;
        [Tooltip("This filters off dead frequencies that can't be heard but can still be seen by the band. A low value filters lower frequencies, a high value filters higher frequencies")]
        [Min(0f)] public float frequencyGate;
        [Tooltip("Makes the band scaling more intense")]
        [Min(0.1f)] public float heightMultiplier;
        [Tooltip("The speed at which each band grows and shrinks. Smaller values move slower, higher values move faster")]
        [Range(0.01f, 0.5f)] public float lerpTime;
        [Tooltip("The color of the band throughout its frequency intensity")]
        public Gradient colorOverFrequency;
        [Tooltip("The speed at which the intensity of this band will go through the colorOverFrequency curve")]
        [Min(1)] public float colorFrequencyMultiplier;
        [Tooltip("The glow of the band throughout its frequency intensity")]
        public AnimationCurve emissionIntensityCurve;
        [Tooltip("The speed at which the intensity of this band will go through the emissionMultiplier curve")]
        [Min(1)] public float emissionMultiplier;
    }
    #endregion

    private void Awake()
    {
        //sets the chosen audio source that this instrument will use
        if (overrideAudioSource == null)
        {
            actualAudioSource = GetComponent<AudioSource>();
        }
        else
        {
            //in case no audio source was chosen, it will simply default to the audio source component present in this game object itself
            GetComponent<VoiceDetection>().enabled = false;
            actualAudioSource = overrideAudioSource;
        }
    }

    private void Start()
    {
        //if the bool is true, the script will create new bands at the start
        if (generateObjsOnSpawn == true)
        GenerateVisualizerObjs();
    }

    [ContextMenu("Generate Visualizer Objs")]
    public void GenerateVisualizerObjs()
    {
        //firstly, delete all the old visualizer information
        ClearVisualizer();

        //averages the scale of each band by dividing the number of bands with the chosen lenght of space that they should ocuppy
        float samplesScales = visualizerSpan / bandParameters.Length;

        //loops for each child that needs to be created
        for (int i = 0; i < bandParameters.Length; i++)
        {
            //creates a child and places it in its adequate position along the span of the visualizer
            var instantiatedObj = Instantiate(visualizerObj, new Vector3((samplesScales * i) - (visualizerSpan / 2) + transform.position.x, transform.position.y, transform.position.z), new Quaternion(0, 0, 0, 0));
            //ensures the scale of the band is correct
            instantiatedObj.transform.localScale = new Vector3(samplesScales, 1, 1);
            //makes the band into a child of the instrument obj
            instantiatedObj.transform.parent = transform;
            //renames the band according to its number within the children
            instantiatedObj.name = "Band " + i;
            //adds a blank color that the band will later use to determine its color, so that the number of colors corresponds to the number of children
            currentColor.Add(Color.black);
        }
    }

    [ContextMenu("Clear Visualizer Objs")]
    public void ClearVisualizer()
    {
        //clears all the children that were within the list of colors for the bands
        currentColor.Clear();

        GameObject currentObj;
        int childs = transform.childCount;

        //goes through each child and deletes it
        for (int i = childs - 1; i >= 0; i--)
        {
            currentObj = transform.GetChild(i).gameObject;

            if (Application.isPlaying == true)
            {
                Destroy(currentObj);
            }
            else
            {
                DestroyImmediate(currentObj);
            }
        }
    }

    void Update()
    {
        // initialize our float array
        //the number 1024 could have been any multiple of 2, up to 8192, but 1024 is more than enough to capture everything needed
        spectrum = new float[1024];

        // populate array with fequency spectrum data
        actualAudioSource.GetSpectrumData(spectrum, 0, FFTWindow.Blackman);

        //setting up blank variables to be used inside the many for loops below
        float instrumentIntensity = 0;
        float currentValue = 0;
        int numberOfFrequencies = 0;
        int currentColorCount = 0;

        //the first for loop is to apply values to each child
        for (int j = 0; transform.childCount > j; j++)
        {

            //the second for loop is to go over each frequency in the spectrum to collect only what is relevant
            for (int i = 0; spectrum.Length > i; i++)
            {

                //the third for loop goes through every range within the array of ranges of each band
                for (int w = 0; bandParameters[j].bandRange.Count > w; w++)
                {
                    //checks to see if the current frequency falls within the range proposed by the previous for loop
                    if (i >= bandParameters[j].bandRange[w].x && i < bandParameters[j].bandRange[w].y)
                    {
                        //the gate is responsible for filtering dead frequencies that constantly get picked up but that are not loud enough to be audible. This happens more often with
                        //microphone capture than instruments, because you can't efficiently stop capturing all the frequencies of a microphone like you could an instrument by simply
                        //stop playing

                        if (bandParameters[j].frequencyGate > spectrum[i])
                        {
                            currentValue += spectrum[i] * 0.1f;
                            numberOfFrequencies++;
                        }
                        else
                        {
                            //if the frequency makes it past all those conditions, it is added to a single value, called currentValue, and the numberOfFrequencies is ticked
                            //up once for each time that a frequency is added to the currentValue

                            currentValue += spectrum[i];
                            numberOfFrequencies++;
                        }
                    }
                }

            }

            //the currentValue is dividied by the number of frequencies that were collected in total, giving us the average that the band can use
            float average = (currentValue / numberOfFrequencies) * bandParameters[j].heightMultiplier;

            //the same averaging techinque described above is then done for each band, because its result will then give us the overall intensity of the instrument
            //which takes into account every band summed together
            instrumentIntensity += average;

            //using the newly found average of the band, a lerp will then smooth out the growth and decay of the value so that it can be fed to the shader's prperties,
            //which are all controlled by the parent of this object
            shaderFrequencyLerp = Mathf.Lerp(GetComponentInParent<InstrumentParent>().skyShader.GetFloat("_Frequency"), shaderFrequencyMultiplier.Evaluate(average), bandParameters[j].lerpTime);
            shaderSpeedLerp = Mathf.Lerp(GetComponentInParent<InstrumentParent>().skyShader.GetFloat("_Speed"), average * shaderSpeedMultiplier, bandParameters[j].lerpTime);

            //the same techinque of smoothing the average is used in the scaling of each individual band
            float lerpY = Mathf.Lerp(transform.GetChild(j).localScale.y, average, bandParameters[j].lerpTime);
            transform.GetChild(j).localScale = new Vector3(transform.GetChild(j).localScale.x, lerpY, transform.localScale.z);

            //in order to safely change the colours of each band without causing many shader issues, we set up a property block for the current material
            var target = transform.GetChild(j).GetComponent<Renderer>();
            var propertyBlock = new MaterialPropertyBlock();

            //using the smoothed out lerpY, this second lerp fits the current value within an inverseLerp which will can be used to move through the color gradient of this band
            float colorLerp = Mathf.InverseLerp(0, spectrum.Length, lerpY * bandParameters[j].colorFrequencyMultiplier);
            //the same thing is done to the emission, so it fits within the animation curve
            float emissionLerp = Mathf.InverseLerp(0, spectrum.Length, lerpY * bandParameters[j].emissionMultiplier);

            //gets all the color and emission values and actually sets them within the property block
            propertyBlock.SetColor("_Color", bandParameters[j].colorOverFrequency.Evaluate(colorLerp) * bandParameters[j].emissionIntensityCurve.Evaluate(emissionLerp));
            currentColor[j] = bandParameters[j].colorOverFrequency.Evaluate(colorLerp) * bandParameters[j].emissionIntensityCurve.Evaluate(emissionLerp);

            //sets the bloock
            target.SetPropertyBlock(propertyBlock);

            //using the usual averaging techinque, we will average out all the colours of this instrument by summing all the band's colors together
            colorAverage += currentColor[j];
            currentColorCount++;
        }

        //the instrument's color average is then divided by the number of bands
        colorAverage /= currentColorCount;

        //as mentioned before, the overall intensity that this instrument outputs is then divided by the number of bands, and this value is sent to the parent
        float instrumentIntensityAveraged = instrumentIntensity / currentColorCount;
        GetComponentInParent<InstrumentParent>().instrumentIntensity[transform.GetSiblingIndex()] = Mathf.InverseLerp(GetComponentInParent<InstrumentParent>().instrumentIntensity[transform.GetSiblingIndex()], maxShaderPositionLerp, instrumentIntensityAveraged);

        //checks to see if the current total intensity of this instrument is sufficient to trigger this instrument's events, and ensures this only happens once, until it resets
        if (instrumentIntensityAveraged >= eventFreqTrigger && canTriggerEvents == true)
        {
            TriggerInstrumentEvent();
        }
        //the -1 is a precaution to make sure it won't trigger the event twice
        else if (instrumentIntensityAveraged <= eventFreqTrigger - 1f)
        {
            canTriggerEvents = true;
        }
    }

    public void TriggerInstrumentEvent()
    {
        canTriggerEvents = false;

        //if the randomness is off, then all the events in this instrument are played out
        if (randomlyPickOneEvent == false)
        {
            for (int i = 0; InstrumentEvents.Count > i; i++)
            {
                InstrumentEvents[i].Invoke();
            }
        }
        //if the randomness is on, it only triggers one chosen event within the events, at random
        else
        {
            if (InstrumentEvents.Count != 0)
            InstrumentEvents[Random.Range(0, InstrumentEvents.Count)].Invoke();
        }
    }
}
